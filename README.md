# SaaS App under Serverless Framework

## Summary:

This project builds a subscription website with AWS and Stripe. It allows users to register, verify email addresses, login, and reset password by using AWS Cognito. A webpage with 3 tiers of subscription plans and 3 corresponding buttons will be presented to the user. The 3 subscription plans are linked to 3 previously configured products on Stripe. By clicking on one of the buttons, the user will be directed to Stripe to finish the payment. An AWS Lambda function listens to the events from Stripe via webhook. Once the payment finishes, Lambda will be notified to trigger Cognito to create a user account. A second Lambda is linked to Cognito for post confirmation trigger. Once the user finishes email verfication, the second Lambda writes the user information to our database. You can either write directly into DynamoDB or use the managed GraphQL service provided by AppSync.

## FrontEnd：

Front end is based on NEXT.JS and React, yarn is highly recommended rather then npm.
[MUI Template website](https://demos.pixinvent.com/materialize-nextjs-admin-template/documentation/guide/)
[Main UI library website](https://mui.com/material-ui/getting-started/overview/)

### Install Dependencies:

`yarn install`

### Run on localhost:

`yarn dev`

[Routing](https://demos.pixinvent.com/materialize-nextjs-admin-template/documentation/guide/development/routing.html#index-routes)
State Management: Context Provider: _src\context\AuthContext.js_

Core business Logic in:
_src\views\pages\tools\templates_
_amplify\backend\function\hbopenAISvr\src_

### FrontEnd Folder Structure Sample:

- /src
  - /@core -> Codes from MUI Template
  - /component -> React small components
  - /configs -> Configurations
    - /profile/onboarding.js -> Onboarding information requirements configurations
    - /tools -> Use case configurations for front-end, dashboard arrangements configurations
      - api.js -> Stripe Price ID (This is public)
  - /context -> Context Provider
    - AuthContext.js -> State for basic information like credits, basic login and logout entry etc.
  - /graphql -> Amplify GraphQL auto-generated folder, includes GraphQL queries mutations etc.
  - /layouts -> Code for top AppBar etc.
  - /models -> Amplify Datastore auto-generated folder.
  - /navigation -> Configuration for left navigation panel.
  - /pages -> All pages (With router, all sub-folders correspond to a path)
  - /ui-components -> Currently not used, Amplify auto-generated front-end components (Through Figma etc.)
  - /views -> Components used in pages, but themselves do not have a route.
  - aws-exports.js -> Correspond backend endpoints configs for frontend (should be auto-generated by amplify)

### SignIn and Render Paywalled Content

This is the last step. We have finished subscription and registration, now users can sign in and view subscription-exclusive contents.

- In `SignIn.js` that you created before, use Cognito's signIn function and create a simple signin form with userName and password.
- In `app.js`, add the Subscribe and SignIn component. Make sure the paywalled content is only shown after subscription.
- A code template:

```
function App () {
  const [user, setUser] = useState(null)
  return (
    <div className='App'>
      <h1>My Fancy Subscription Site</h1>
      <Subscribe />
      {user
        ? <h1>Paywalled content!</h1>
        : <SignIn setUser={setUser} />}
    </div>
  )
}
```

## BackEnd：

Amplify CLI is highly recommended.

### Backend Folder Structure Sample (inside /amplify/function/, may not be latest code in this repo):

- /src
  - /ai -> Core business Logic folder
    - /one-step -> Backend logics and prompts configuration file for one step use cases
    - /step-by-step -> Backend logics and prompts configuration file for step by step use cases
    - index.js -> Accept request from front end, request to OPEN AI models and calculate credit used
  - /config -> Backend configs (Include stripe price IDs, DynamoDB table names, **AND SOME SECRET KEYS, DO NOT SHARE CODE TO PUBLIC, CONFIGURE ADDITIONAL ENV AND SECRET VALUES IN LAMBDA WILL CAUSE POTENTIAL WHOLE AMPLIFY BACKEND DEPLOYMENT ERROR, NOT FIXED BY AWS UNTIL 03/2023**)
  - /db -> Some reuseable database operation
  - /user -> Business logic for users (request stripe subscription etc.)
  - app.js -> Express server file, include stripe webhook entry point and some unclassified logics.
  - index.js -> Lambda entry file, deal with pre-sign-up and post-sign-up trigger and pass request to app.js for API GATEWAY requests.
  - stripe.js -> Detailed payment logic from stripe webhook (process subscription creation, update, delete and invoice payment from stripe)

### APIs and Functions: API Gateway, AppSynce and AWS Lambda

#### REST API: API Gateway

Using API GateWay and aws lambda function
[Amplify REST API(API Gateway)](https://docs.amplify.aws/lib/restapi/getting-started/q/platform/js/#manual-setup-reference-existing-rest-api)
_amplify\backend\api\lmdGateway\cli-inputs.json_

Express Node JS server is used in Lambda with API GateWay for APIs
(i.e. OPEN AI requests, subscription requests, database updates with security check, stripe webhooks)
API Gate way will include Cognito sub ID in request
[Lambda Function](https://docs.amplify.aws/cli/function/)
_amplify\backend\function\hbopenAISvr\src_

### GraphQL API: AppSync

The second option, which is more recommended, is to use a GraphQL API to access the database. The fundamental idea of a GraphQL API is that all API functionality is available via a unified query language (the Graph Query Language) under a single endpoint. Rather than making requests to various endpoints to get different parts of the data needed to build a webpage, developers can issue a single request to a GraphQL API and immediately get back all the data they need.

AppSnyc is a fully managed GraphQL service that simplifies the work of building a GraphQL API. It handles the parsing and resolution of requests and integrates well with other AWS services. You can flexibly add and manage more data sources like AWS Elastic Search to AppSync in the future.

- Open AWS CLI in root directory of your App, type: `amplify add api`, then choose `GraphQL`
- Edit the generated schema text file `schema.graphql` in the api folder of your amplify backend.
- The following is a template schema:

```
type User @model
  @auth(rules: [
    { allow: groups, groups: ["Admin"] },
    { allow: owner, ownerField: "username", operations: [read] }
  ]) {
  id: ID!
  username: String!
  email: String!
}
```

- Update the changes to the cloud, which will create an AppSync API, a DynamoDB table, and local GraphQL operations for a query

```
amplify push --y
```

- Add frontend code to perform user creation through the API. We will use the same code template in last section of direct writing into DynamoDB
- First, import the packages for CRUD operation on User

```
import { listUsers } from "./graphql/queries";
import {
  createUser as createUserMutation,
  deleteUser as deleteUserMutation,
} from "./graphql/mutations";
```

- Change the format of data input
- Change the try-catch block to creation operations through GraphQL
- Here is a final code template

```
var aws = require('aws-sdk')

exports.handler = async (event, context) => {
    let date = new Date()
    if (event.request.userAttributes.sub) {
        const data = {
                id: {S: event.request.userAttributes.sub},
                username: {S: event.userName},
                email: {S: event.request.userAttributes.email},
                createdAt: {S: date.toISOString()},
                updatedAt: {S: date.toISOString()},
        }

        try {
            await API.graphql({
              query: createNoteMutation,
              variables: { input: data },
            });
            console.log("Success")
        } catch (err) {
            console.log("Error", err)
        }

        console.log("Success: Everything executed correctly")
        context.done(null, event)

    } else {
        console.log("Error: Nothing was written to DynamoDB")
        context.done(null, event)
    }
};
```

### Function: AWS Lambda

#### Write the Logic of Lambda Function

- `cd` into `src/` of your lambda backend folder
- Install packages: `npm i aws-sdk stripe`
- In `app.js`, the function for Lambda to retreive your Stripe API key is already provided
- Set up the Express service using the following code

```
const express = require('express')
const bodyParser = require('body-parser')
const awsServerlessExpressMiddleware = require('aws-serverless-express/middleware')
const aws = require('aws-sdk')

// declare a new express app
const app = express()
app.use(bodyParser.json({
  verify: function (req, res, buf) {
    req.rawBody = buf.toString()
  }
}))
app.use(awsServerlessExpressMiddleware.eventContext())
// Enable CORS for all methods
app.use(function (req, res, next) {
  res.header('Access-Control-Allow-Origin', '*')
  res.header('Access-Control-Allow-Headers', '*')
  next()
})

app.listen(3000, function () {
  console.log('App started')
})
```

### Set up Amplify, Lambda, and Rest API in AWS CLI

- Using AWS CLI, initialize Amplify and add authentication services provided by Cognito

```
amplify init
amplify add auth
```

- Add an API and choose Rest API for the webhook we will use later: `amplify add api`
- Add a Lambda function. Give it access to `auth` and permit `create, read, update, delete` operations
- Configure the secret key to be accessed by Lambda function. It is the `secret key` of Stripe next to where you found your Publishable Key.
- `amplify push` to update the changes

## Database:

[AWS DynamoDB](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/AccessingDynamoDB.html)
_amplify\backend\api\hbopenaiapp\schema.graphql_
**Be aware of Auth Rules: (i.e. remain credits, plan details is only readable to owners etc.)**

### DynamoDB Table Layout

The following graphs show the recommended schema for a single user table in DynamoDB.

![DB ER](https://user-images.githubusercontent.com/91907021/228631754-9b775b4c-ed92-4a73-ad21-8abf815b92a6.png)
![DB key-value pairs](https://user-images.githubusercontent.com/91907021/228632415-5fb531cd-634c-43c5-999c-9ccaa6e98ec0.jpg)

### Ways to access DynamoDB:

1. Access Inside Lambda function: (used to modify credits etc.)
   [AWS-SDK Document Client](https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/DynamoDB/DocumentClient.html)
   **This will not update Amplify DataStore in real-time, use GraphQL if need real-time update with Amplify Datastore (example use case: stock price real-time update)**

2. Front End Access:
   [AWS GraphQL API](https://docs.amplify.aws/lib/graphqlapi/getting-started/q/platform/js/)

- Use GraphQL: this is recommended to access and change data that needs to sync with database immediately (user credits, user plans)
  _src\graphql_
  [AWS DataStore](https://docs.amplify.aws/lib/datastore/getting-started/q/platform/js/)
- Use DataStore: this is recommended to access and change data that that does not need to sync with database immediately (user modifiable request history, user editable profile)

### Write Directly Into DynamoDB:

The first option is to create an DynamoDB instance and directly put data into DynamoDB.

- `Item` corresponds to one entry in the database and each item has attributes corresponding to the attributes in your GraphQL schema.
- Following is an example code template:

```
var aws = require('aws-sdk')
var ddb = new aws.DynamoDB()

exports.handler = async (event, context) => {
    let date = new Date()
    if (event.request.userAttributes.sub) {
        let params = {
            Item: {
                'id': {S: event.request.userAttributes.sub},
                '__typename': {S: 'User'},
                'username': {S: event.userName},
                'email': {S: event.request.userAttributes.email},
                'createdAt': {S: date.toISOString()},
                'updatedAt': {S: date.toISOString()},
            },
            TableName: process.env.USERTABLE
        }

        try {
            await ddb.putItem(params).promise()
            console.log("Success")
        } catch (err) {
            console.log("Error", err)
        }

        console.log("Success: Everything executed correctly")
        context.done(null, event)

    } else {
        console.log("Error: Nothing was written to DynamoDB")
        context.done(null, event)
    }
};
```

## Shared Services:

### User Authentication: Cognito

_amplify\backend\auth\hbOpenAIapp\cli-inputs.json_
[AWS Cognito](https://docs.amplify.aws/lib/auth/getting-started/q/platform/js/)
Email sign-up and sign-in, using email to recover account, also need Full Name when sign-up. (Used for potential branding email)
Sign-In with Google: [Social Sign-in](https://docs.amplify.aws/lib/auth/social/q/platform/js/)

#### Pre-Sign-Up Lambda Trigger:

1. Used to connect existing account when sign-in with Google, and block sign-up when there is already a google account
2. Used to check email alias
3. Used to block unexpected email sign-up [Email API](https://www.kleanmail.com/developers)

#### Post-Sign-Up Lambda Trigger:

1. Used to Initialize custom user data (free credits, etc.) based on email type

#### Write User Data Into Database:

- There are two options to write user data into the database. The first several steps are the same for both options.
- Add another Lambda function to the Amplify backend. It will serve as a trigger to write into DynamoDB after a user verifies his/her email during Cognito authentication.
- In Cognito (CLI or UI), link the Lambda function, and choose `PostConfirmationTrigger`.
- In `src/custom.js`, write an event handler function. It will take an incoming event from Cognito, parse the user info in the event, and write the parsed info into DynamoDB.

#### Write the Logic of Webhook and Cognito in Lambda:

We will use webhook to "hook" Lambda and Stripe together. Once an event of successful payment is generated by Stripe, Stripe will send it to the hook address of Lambda. Lambda will be automatically triggered and parse the request body. Then, a user account will be created through Cognito adminAPI. We first set up the hook on the Lambda side.

- In `app.js`, get your `userPoolId` in the comments
- Write a `post` functions that receives request body to webhook route
- In `post`, parse the user's information sent by Stripe
- In this code, we've used the withAuthenticator component. It will lay out an entire user authentication flow allowing users to sign up, sign in, reset their password, and confirm sign-in for multifactor authentication (MFA). We have also added a Sign Out button to log users out.
- A code template:

```
app.post('/webhook', async function (req, res) {
  const stripeKey = await getStripeKey()
  const stripe = require('stripe')(stripeKey)
  console.log(stripeKey)

  const customer = await stripe.customers.retrieve(
    req.body.data.object.customer
  )

  const userEmail = customer.email

function App({ signOut }) {
  return (
    <View className="App">
      <Card>
        <Image src={logo} className="App-logo" alt="logo" />
        <Heading level={1}>We now have Auth!</Heading>
      </Card>
      <Button onClick={signOut}>Sign Out</Button>
    </View>
  );
}
})
```

### Billing Management: Stripe

[Stripe Doc](https://stripe.com/docs/api)

- Payment Type: Monthly subscription, credits are given per subscription cycle and will not carry to next cycle.
- Free trial info is managed inside the app and will not sync with Stripe.
- Stripe web hook will use signature verification so for the webhook API Gateway address no other Auth is needed and should use raw body for signature verification.

#### First time Subscription Payment Flow:

- Generate a product and some price IDs through stripe
- Both front-end and back-end maintain the price ID, backend maintains stripe key and stripe webhook endpoint secret.
- Frontend choose subscription plan and call backend with that price ID and a redirect address
- Backend uses price ID, redirect address, its own stripe key and customer identifier (user email for the first time and stripe customer id for the rest, customer id is like remaining credits, they are only editable in backend) to request a check-out page address from stripe.
- Backend return this address to front-end, front-end jump out to check-out page managed by stripe.
- After payment success/fail/cancel, stripe will direct back to our app address.
- Stripe will send payment result through webhook(with user information), lambda backend will update subscription information based on the result (also customer ID is generated by stripe for the first time, store it to database)

#### Subscription Status Change:

- User could change subscription status(cancel/un-cancel/change-plan subscription when current period ends) in a similar flow, but no stripe checkout page is needed. If plan is changed, a custom proration logic (in this app full price difference will be charged (because credit is increased immediately) , and if downgrade there is no refund (credits for the higher level could still be used for current period and will change for the next period))

#### Subscription Renewal/Cancell:

- When a subscription period is end, if is subscription is not canceled, stripe will try to charge customer's card, if success: stripe update subscription information through webhook and lambda will update user information. If charge is failed or plan is canceled: stripe will send subscription deleted information to webhook and lambda will cancel benefits. After subscription expired/charge failed, re-subscription will need to go first-time-subscription flow.

Backend Folder Structure (inside /amplify/function/, may not be latest code in this repo):

#### Link Stripe to Your App

- Create your React App and cd into the App folder
- Install packages: `npm i aws-amplify @stripe/stripe.js`
- Create 2 files that will be edited later: `SignIn.js` and `Subscribe.js`
- We will edit the Subscribe file first in the following section

##### Get API Key from Stripe

- Create a Stripe account
- Create 3 products using the Stripe dashboard. Get your `Stripe Publishable Key` under "Get your API keys". In product details page, get each Product Key under `API ID` next to “price”.

##### `Subscribe.js` Create Event Handlers and Buttons

- In `Subscribe.js`, import packages: `import { loadStripe } from '@stripe/stripe-js'`
- Create 3 event handlers with 3 buttons for each product in your Stripe account. When user clicks on one button, he/she will be redirected to the corresponding product on Stripe. Following is a template for one event handler:

```
const handleClick = async e => {
  const stripe = await loadStripe('your_stripe_publishable_key')
  const { error } = await stripe.redirectToCheckout({
    lineItems: [{
      price: 'price_key',
      quantity: 1
    }],
    mode: 'subscription',
    successUrl: 'http://localhost:3000/',
    cancelUrl: 'http://localhost:3000/cancel'
  })
}
```

- In each event handler, change the content in `loadStripe` to your `Stripe Publishable Key`. Change “price” to the 'API ID`. Make sure the `mode: subscription`is correct. Provide the link to your homepage for`successUrl`and your payment-canceled page to`cancelUrl`.
- Now `Subscribe.js` is finished. It is rendered in `App.js`.

#### Create the Webhook on Stripe:

- Get the Url of your app. In `src/` -> `aws-exports.js`, find the `endpoint` key.
- Append the url string in the post function to the `endpoint` url. For example, `https.../webhook`
- In Stripe Dashboard, go to `Developers` -> `Webhooks` -> `+ Add Endpoint`, choose `payment_intent.succeeded` as the event to listen for, paste the entire url in last step

## Updating...

- 14-day Free Trial for the subscription
- Paywalled content: candidate search via ElasticSearch

## Helpful Resources

[1] https://www.youtube.com/watch?v=Sk9HMuAaTmQ

[2] https://welearncode.com/stripe-amplify/

[3] https://aws.amazon.com/getting-started/hands-on/build-react-app-amplify-graphql/module-three/

[4] https://dzone.com/articles/from-aws-cognito-to-dynamobd-using-triggers

[5] https://www.serverless.com/guides/aws-appsync
